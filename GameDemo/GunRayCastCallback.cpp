/*
 *  GunRayCastCallback.cpp
 *  Dirac2D
 *
 *  Created by Prashant on 12/12/12.
 *
 */

#include "GunRayCastCallback.h"
#include "Dirac2D.h"
#include "GameObject.h"
#include "ObjectManager.h"
#include "FirstGame.h"

USE_NAMESPACE_DIRAC2D

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


GunRayCastClosestCallBack::GunRayCastClosestCallBack(FirstGame* pGame)
{
	m_pGame = pGame;
	m_pObject = 0;
}

// Any Intersection with the Ray cast will be reported here.
float GunRayCastClosestCallBack::rayIntersectionCallBack(const RaySegment2f& raySeg, PhysicalShape* pShape, RayIntersectionInfo& info)
{	
	GameObject* pObject = (GameObject*)pShape->getUserData();
    
    if( pObject )
    {
		if( pObject->getGameObjectInfo().m_ObjectType != EOT_CRATE )
        {
			return -1.0f;
		}
        
		m_pObject = pObject;
		m_IntersectionInfo = info;
    }
    else
    {
        return -1.0f;
    }
	return info.m_HitT;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


GunRayCastManyCallBack::GunRayCastManyCallBack(FirstGame* pGame )
{
	m_pGame = pGame;
	m_MaxObjectPickCount = 10;
	for( int i=0; i<m_MaxObjectPickCount; i++ )
		m_pObject[i] = 0;
	
	m_ObjectCounter = 0;
}


float GunRayCastManyCallBack::rayIntersectionCallBack(const RaySegment2f& raySeg, PhysicalShape* pShape, RayIntersectionInfo& info)
{
	GameObject* pObject = (GameObject*)pShape->getUserData();
    if( m_ObjectCounter >= m_MaxObjectPickCount )
		return 0.0f;
	
    if( pObject )
    {
		if( pObject->getGameObjectInfo().m_ObjectType != EOT_CRATE
           && pObject->getGameObjectInfo().m_ObjectType != EOT_PATH_HURDLE)
        {
			return -1.0f;
		}
        
		m_pObject[m_ObjectCounter] = pObject;
		m_IntersectionInfo[m_ObjectCounter] = info;
    }
    else
    {
        return -1.0f;
    }
	m_ObjectCounter++;
	return 1.0f;
}